{"ast":null,"code":"/**\r\n * @author Andrew Redican <andrew.redican.mejia@gmail.com>\r\n */\n\n/**\r\n * Performs deep search on object tree, removes all properties with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\nfunction _deepRemoveAll_Key(identity, keyName, maxDepth) {\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var clonedIdentity = _deepClone2(identity);\n\n  var paths = _locateAll_Key2(clonedIdentity, keyName, maxDepth);\n\n  if (paths === [] || paths === false) return clonedIdentity;\n  paths.forEach(function (path) {\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var ref = clonedIdentity;\n    if (!Array.isArray(path)) delete ref[path];\n\n    for (var i = 0; i < path.length; i++) {\n      var key = path[i];\n\n      if (key in ref) {\n        if (i < path.length - 1) ref = ref[key];else delete ref[key];\n      } else break;\n    }\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, removes the first property with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _deepRemove_Key(identity, keyName, maxDepth) {\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var clonedIdentity = _deepClone2(identity);\n\n  var path = _locate_Key2(clonedIdentity, keyName, maxDepth);\n\n  if (path === false) return clonedIdentity;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var ref = clonedIdentity;\n  if (!Array.isArray(path)) delete ref[path];\n  path.forEach(function (key, i) {\n    if (i < path.length - 1) ref = ref[key];else delete ref[key];\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, and renames the all matching keys\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _renameKeys2(identity, keyName, newKeyName) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (_getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n\n  function _renameKeys(identity, keyName, newKeyName, maxDepth) {\n    var currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var keys;\n\n    switch (_getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var _key = keys[i],\n              _subIdentity = identity[_key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (_key === keyName) _key = newKeyName;\n          Obj[_key] = _renameKeys(_subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKeys(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Performs deep search on object tree, then renames the first matching key\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _renameKey2(identity, keyName, newKeyName) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (_getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n  var applied = false;\n\n  function _renameKey(identity, keyName, newKeyName, maxDepth) {\n    var currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var keys;\n\n    switch (_getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          var _key2 = keys[i],\n              _subIdentity2 = identity[_key2];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (!applied) if (_key2 === keyName) {\n            _key2 = newKeyName;\n            applied = true;\n          }\n          Obj[_key2] = _renameKey(_subIdentity2, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKey(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Creates a non-reference clone that is an exact copy to the identity provided.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @param {Optional Number} startDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction _deepClone2(identity) {\n  var maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var startDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var R = [];\n\n  function _deepClone(identity, maxDepth, startDepth) {\n    var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var keys;\n\n    if (startDepth !== null ? currentDepth < startDepth : false) {\n      if (_isIterable(identity)) {\n        keys = Object.keys(identity);\n        keys.forEach(function (key) {\n          _deepClone(identity[key], maxDepth, startDepth, currentDepth + 1);\n        });\n      }\n\n      return;\n    }\n\n    if (startDepth !== null ? currentDepth == startDepth : false) {\n      if (startDepth == 0) {\n        R = _deepClone(identity, maxDepth, null, currentDepth);\n        return;\n      }\n\n      if (_isIterable(identity)) R.push(_deepClone(identity, maxDepth, startDepth, currentDepth + 1));\n      return;\n    }\n\n    switch (_getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          var key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          var _key3 = keys[i],\n              _subIdentity3 = identity[_key3];\n          Obj[_key3] = _deepClone(_subIdentity3, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  if (startDepth === null) return _deepClone(identity, maxDepth, startDepth, 0);\n\n  _deepClone(identity, maxDepth, startDepth, 0);\n\n  return R;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, and returns a list of identities containing the matched instances. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} Identities\r\n */\n\n\nfunction _deepFilter_Key(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var paths = _locateAll_Key2(collection, keyName, maxDepth);\n\n  if (paths === false) return undefined;\n  var results = paths.map(function (path) {\n    if (path === false) return undefined;\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(function (key) {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, returns the location of each match in a string array. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction _locateAll_Key2(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var R = [];\n\n  function _locateAll_Key(collection, keyName) {\n    var xKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    var maxDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var currentDepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    if (xKey === keyName) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key];\n\n      _locateAll_Key(subcollection, keyName, key, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll_Key(collection, keyName, '', '', maxDepth);\n\n  R = R.map(function (path) {\n    if (_getType(path) === 'boolean') return path;\n    if (path === '') return path;\n    path = path.split('.');\n    path.pop();\n    path = path.join('.');\n    return path;\n  });\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, and returns the first identity containing the match. If no match found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {Identity || undefined} identity\r\n */\n\n\nfunction _deepGet_Key(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  var path = _locate_Key2(collection, keyName, maxDepth);\n\n  if (path === false) return undefined;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(function (key) {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, will return the path of the first instance matched. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {String || false} Path\r\n */\n\n\nfunction _locate_Key2(collection, keyName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (_getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  function _locate_Key(collection, keyName) {\n    var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var maxDepth = arguments.length > 3 ? arguments[3] : undefined;\n    var currentDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (path === keyName) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _locate_Key(subcollection, keyName, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  var path = _locate_Key(collection, keyName, '', maxDepth, 0);\n\n  if (_getType(path) === 'boolean') return path;\n  if (path === '') return path;\n  path = path.split('.');\n  path.pop();\n  path = path.join('.');\n  return path;\n}\n/**\r\n * Performs deep search for identity on collection to return the location's depth of the first match. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean}\r\n */\n\n\nfunction _matchDepth(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  var path = _locate2(collection, identity, maxDepth);\n\n  if (path === false) return false;\n  if (path === '') return 0;\n  path = path.split('.');\n  return path.length;\n}\n/**\r\n * Walks through the entire object tree to return the maximum number of layers it contains.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n */\n\n\nfunction _maxDepth2(identity) {\n  var maxLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var R = 0;\n\n  function _maxDepth(identity, maxLayer) {\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (R < currentDepth) R = currentDepth;\n    if (maxLayer !== null) if (currentDepth >= maxLayer) return;\n\n    if (_isIterable(identity)) {\n      var keys = Object.keys(identity);\n      keys.forEach(function (key) {\n        var subIdentity = identity[key];\n\n        _maxDepth(subIdentity, maxLayer, currentDepth + 1);\n      });\n    }\n  }\n\n  _maxDepth(identity, maxLayer);\n\n  return R;\n}\n/**\r\n * Performs deep search for identity on collection, returns the number of matches found.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Number} nthDepth\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns number of matches found.\r\n */\n\n\nfunction _countMatches(collection, identity) {\n  var nthDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var depth,\n      nthDepth_isNull = nthDepth === null,\n      maxDepth_isNull = maxDepth === null;\n  if (nthDepth_isNull && maxDepth_isNull) depth = null;else if (!nthDepth_isNull && !maxDepth_isNull) {\n    if (nthDepth < maxDepth) depth = nthDepth;else depth = maxDepth;\n  } else if (nthDepth) depth = nthDepth;else depth = maxDepth;\n\n  var paths = _locateAll2(collection, identity, depth);\n\n  if (paths === false) return 0;\n  if (nthDepth === null) return paths.length;\n\n  if (_getType(nthDepth) === 'number') {\n    var count = 0;\n    paths.forEach(function (path) {\n      path = path.split('.');\n      if (path.length === nthDepth) count++;\n    });\n    return count;\n  }\n\n  return undefined;\n}\n/**\r\n* Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n* @param {Any} collection\r\n* @param {Any} identities\r\n* @param {Any} property\r\n* @param {Optional Number} maxDepth\r\n* @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n*/\n\n\nfunction _onlyFalsy(collection, identities, property) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      var subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundFalsy2(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key],\n          subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundFalsy2(subCollection, property, maxDepth)) _result[key] = identity;\n    });\n    return _result;\n  }\n\n  if (_foundFalsy2(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction _foundFalsy2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  identity = singleProperty(identity);\n  if (_isFalsy(identity)) return undefined;\n\n  function _foundFalsy(collection, identity, maxDepth) {\n    var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (_containsKeys(collection, [identity])) return _isFalsy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _foundFalsy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundFalsy(collection, identity, maxDepth);\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Any} property\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction _onlyTruthy(collection, identities, property) {\n  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      var subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundTruthy2(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result2 = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key],\n          subCollection = _deepFilter(collection, identity);\n\n      if (_isTruthy(subCollection)) if (_foundTruthy2(subCollection, property, maxDepth)) _result2[key] = identity;\n    });\n    return _result2;\n  }\n\n  if (_foundTruthy2(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction _foundTruthy2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  identity = singleProperty(identity);\n  if (_isFalsy(identity)) return undefined;\n\n  function _foundTruthy(collection, identity, maxDepth) {\n    var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    if (_containsKeys(collection, [identity])) return _isTruthy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _foundTruthy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundTruthy(collection, identity, maxDepth, 0);\n}\n/**\r\n * Validates if identity is equal to a property definition or contains a single property key.\r\n * @param {Property} identity\r\n * @return {String || boolean} If criteria matched will return property name as string, otherwise false\r\n */\n\n\nfunction singleProperty(identity) {\n  var propCount = _length(identity);\n\n  if (propCount > 1) return false;\n  if (propCount === 1) return Object.keys(identity)[0];\n  if (propCount === 0) if (['string', 'number'].indexOf(_getType(identity)) > -1) return identity;\n  return false;\n}\n/**\r\n * Determines if identity is non-falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction _isTruthy(identity) {\n  return !_isFalsy(identity);\n}\n/**\r\n * Determines if identity is falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction _isFalsy(identity) {\n  if (falser(identity) === false) return true;\n  return false;\n}\n/**\r\n * Converts false-like values into actual boolean value of false\r\n * @param {Any} identity\r\n * @return {Any || boolean} Returns false is value is falsy, otherwise returns original value.\r\n */\n\n\nfunction falser(identity) {\n  if (_isIterable(identity)) return identity;\n  if (['null', 'undefined'].indexOf(_getType(identity)) > -1) return false;\n  if (['', 0, false].indexOf(identity) > -1) return false;\n  return identity;\n}\n/**\r\n * Check the length of the top-most depth of the identity\r\n * @param {Any} identity\r\n * @return {integer} Greater than or equal to 0.\r\n */\n\n\nfunction _length(identity) {\n  if (['array', 'object'].indexOf(_getType(identity)) === -1) return 0;\n  return Object.keys(identity).length;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that does meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that were not matched.\r\n */\n\n\nfunction _onlyMissing(collection, identities) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      if (!_exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result3 = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key];\n      if (!_exists(collection, identity, maxDepth)) _result3[key] = identity;\n    });\n    return _result3;\n  }\n\n  if (!_exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction _onlyExisting(collection, identities) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  if (_getType(identities) === 'array') {\n    var result = [];\n    identities.forEach(function (identity) {\n      if (_exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (_getType(identities) === 'object') {\n    var _result4 = {};\n    Object.keys(identities).forEach(function (key) {\n      var identity = identities[key];\n      if (_exists(collection, identity, maxDepth)) _result4[key] = identity;\n    });\n    return _result4;\n  }\n\n  if (_exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the identity\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If a match is confirmed will return true, otherwise false\r\n */\n\n\nfunction _exists(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  if (_identical(collection, identity)) return true;\n  if (_isIterable(identity)) if (_sameType(collection, identity)) if (_containsKeys(collection, Object.keys(identity))) {\n    var trimmed = _trim(collection, Object.keys(identity));\n\n    if (_identical(trimmed, identity)) return true;\n  }\n  if (maxDepth === null ? true : currentDepth < maxDepth) if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n    var key = keys[i],\n        subcollection = collection[key],\n        res = _exists(subcollection, identity, maxDepth, currentDepth + 1);\n\n    if (res) return true;\n  }\n  return false;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, will return a list of identities containing the match. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} identities\r\n */\n\n\nfunction _deepFilter(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  var paths = _locateAll2(collection, identity, maxDepth);\n\n  if (paths === false) return undefined;\n  var results = paths.map(function (path) {\n    if (path === '') return collection;\n    path = path.split('.');\n    if (['array', 'object'].indexOf(_getType(identity)) === -1) path.splice(-1, 1);\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(function (key) {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, returns a string array containing the location of all matches. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction _locateAll2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var R = [];\n\n  function _locateAll(collection, identity) {\n    var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var maxDepth = arguments.length > 3 ? arguments[3] : undefined;\n    var currentDepth = arguments.length > 4 ? arguments[4] : undefined;\n    if (_isIterable(identity)) if (_sameType(collection, identity)) if (_containsKeys(collection, Object.keys(identity))) {\n      var trimmed = _trim(collection, Object.keys(identity));\n\n      if (_identical(trimmed, identity)) R[R.length] = path;\n    }\n    if (_identical(collection, identity)) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key];\n\n      _locateAll(subcollection, identity, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll(collection, identity, '', maxDepth, 0);\n\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the identity containing of the first instance matched. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {identity || undefined} identity\r\n */\n\n\nfunction _deepGet(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  var path = _locate2(collection, identity, maxDepth);\n\n  if (path === false) return undefined;\n  if (path === '') return collection;\n  path = path.split('.');\n  if (['array', 'object'].indexOf(_getType(identity)) === -1) path.splice(-1, 1);\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(function (key) {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the path of the first instance matched as string. If no matches found, returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional number} maxDepth\r\n * @return {string || false} path\r\n */\n\n\nfunction _locate2(collection, identity) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  function _locate(collection, identity) {\n    var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    var maxDepth = arguments.length > 3 ? arguments[3] : undefined;\n    var currentDepth = arguments.length > 4 ? arguments[4] : undefined;\n    if (_isIterable(identity)) if (_sameType(collection, identity)) if (_containsKeys(collection, Object.keys(identity))) {\n      var trimmed = _trim(collection, Object.keys(identity));\n\n      if (_identical(trimmed, identity)) return path;\n    }\n    if (_identical(collection, identity)) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (_isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      var key = keys[i],\n          subcollection = collection[key],\n          res = _locate(subcollection, identity, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  return _locate(collection, identity, '', maxDepth, 0);\n}\n/**\r\n * Trims an identity to only contain the specified properties.\r\n * @param {Any} identity\r\n * @param {Any} keyList\r\n * @return {Object or Array} Returns , otherwise false\r\n */\n\n\nfunction _trim(identity, keyList) {\n  var identityType = _getType(identity);\n\n  if (['array', 'object'].indexOf(identityType) === -1) return undefined;\n  var keyCount = keyList.length;\n  if (keyCount === 0) return undefined;\n  var newIdentity;\n\n  switch (identityType) {\n    case 'object':\n      newIdentity = {};\n      keyList.forEach(function (key) {\n        if (key in identity) newIdentity[key] = identity[key];\n      });\n      break;\n\n    case 'array':\n      newIdentity = [];\n      keyList.forEach(function (key) {\n        if (key in identity) newIdentity.push(identity[key]);\n      });\n      break;\n  }\n\n  return newIdentity;\n}\n/**\r\n * Check if identity contains all of the specified keys\r\n * @param {Any} identity\r\n * @param {Array} keyList\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _containsKeys(identity, keyList) {\n  var keyCount = keyList.length;\n  if (keyCount === 0 || !_isIterable(identity)) return false;\n  var identitykeys = Object.keys(identity);\n  var result = true;\n\n  for (var i = 0; i < keyCount; i++) {\n    var key = '' + keyList[i];\n\n    if (identitykeys.indexOf(key) === -1) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Check if identity has one or more keys to iterate\r\n * @param {Any} identity\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _isIterable(identity) {\n  if (['array', 'object'].indexOf(_getType(identity)) === -1) return false;\n  if (Object.keys(identity).length === 0) return false;\n  return true;\n}\n/**\r\n * Compares two identities, will return either true if identical, otherwise false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _identical(identityA, identityB) {\n  var structureMatch = _sameStructure(identityA, identityB);\n\n  if (structureMatch === false) return structureMatch;\n  if (['array', 'object'].indexOf(structureMatch) === -1) return identityA === identityB;\n  var Keys = Object.keys(identityA),\n      KeyCount = Keys.length;\n  var childMatch = true;\n\n  for (var i = 0; i < KeyCount; i++) {\n    var Key = Keys[i],\n        identicalMatch = _identical(identityA[Key], identityB[Key]);\n\n    if (identicalMatch === false) {\n      childMatch = identicalMatch;\n      break;\n    }\n\n    ;\n  }\n\n  return childMatch;\n}\n/**\r\n * Compares data structure of two identities, will return either the dataType or true/false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {String || False} DataType as string for positive match, otherwise false\r\n */\n\n\nfunction _sameStructure(identityA, identityB) {\n  var typeMatch = _sameType(identityA, identityB);\n\n  if (typeMatch === false) return false;\n\n  if (['array', 'object'].indexOf(typeMatch) > -1) {\n    var AKeys = Object.keys(identityA),\n        BKeys = Object.keys(identityB),\n        AKeyCount = AKeys.length,\n        BKeyCount = BKeys.length;\n    if (!(AKeyCount === BKeyCount)) return false;\n    if (AKeyCount === 0) return true;\n\n    for (var i = 0; i < AKeyCount; i++) {\n      if (AKeys[i] !== BKeys[i]) return false;\n    }\n  }\n\n  return typeMatch;\n}\n/**\r\n * Compares data type of two identities, will dataType if true.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction _sameType(identityA, identityB) {\n  var typeA = _getType(identityA);\n\n  return typeA === _getType(identityB) ? typeA : false;\n}\n/**\r\n * Gets data type; makes distintion between object, array, and null.\r\n * @param {Any} identity\r\n * @return {String} dataType\r\n */\n\n\nfunction _getType(identity) {\n  if (identity === null) return 'null';\n  var it = typeof identity;\n  if (it === 'object') if (Array.isArray(identity)) return 'array';\n  return it;\n}\n\nvar mitsuketa = {\n  getType: function getType(identity) {\n    return _getType(identity);\n  },\n  sameType: function sameType(identityA, identityB) {\n    return _sameType(identityA, identityB);\n  },\n  sameStructure: function sameStructure(identityA, identityB) {\n    return _sameStructure(identityA, identityB);\n  },\n  identical: function identical(identityA, identityB) {\n    return _identical(identityA, identityB);\n  },\n  isIterable: function isIterable(identity) {\n    return _isIterable(identity);\n  },\n  containsKeys: function containsKeys(identity, keyList) {\n    return _containsKeys(identity, keyList);\n  },\n  trim: function trim(identity, keyList) {\n    return _trim(identity, keyList);\n  },\n  locate: function locate(collection, identity, maxDepth) {\n    return _locate2(collection, identity, maxDepth);\n  },\n  deepGet: function deepGet(collection, identity, maxDepth) {\n    return _deepGet(collection, identity, maxDepth);\n  },\n  locateAll: function locateAll(collection, identity, maxDepth) {\n    return _locateAll2(collection, identity, maxDepth);\n  },\n  deepFilter: function deepFilter(collection, identity, maxDepth) {\n    return _deepFilter(collection, identity, maxDepth);\n  },\n  exists: function exists(collection, identity, maxDepth) {\n    return _exists(collection, identity, maxDepth);\n  },\n  onlyExisting: function onlyExisting(collection, identities, maxDepth) {\n    return _onlyExisting(collection, identities, maxDepth);\n  },\n  onlyMissing: function onlyMissing(collection, identities, maxDepth) {\n    return _onlyMissing(collection, identities, maxDepth);\n  },\n  length: function length(identity) {\n    return _length(identity);\n  },\n  isFalsy: function isFalsy(identity) {\n    return _isFalsy(identity);\n  },\n  isTruthy: function isTruthy(identity) {\n    return _isTruthy(identity);\n  },\n  foundTruthy: function foundTruthy(collection, identity, maxDepth) {\n    return _foundTruthy2(collection, identity, maxDepth);\n  },\n  onlyTruthy: function onlyTruthy(collection, identities, property, maxDepth) {\n    return _onlyTruthy(collection, identities, property, maxDepth);\n  },\n  foundFalsy: function foundFalsy(collection, identity, maxDepth) {\n    return _foundFalsy2(collection, identity, maxDepth);\n  },\n  onlyFalsy: function onlyFalsy(collection, identities, property, maxDepth) {\n    return _onlyFalsy(collection, identities, property, maxDepth);\n  },\n  countMatches: function countMatches(collection, identity, nthDepth, maxDepth) {\n    return _countMatches(collection, identity, nthDepth, maxDepth);\n  },\n  matchDepth: function matchDepth(collection, identity, maxDepth) {\n    return _matchDepth(collection, identity, maxDepth);\n  },\n  maxDepth: function maxDepth(identity, maxLayer) {\n    return _maxDepth2(identity, maxLayer);\n  },\n  locate_Key: function locate_Key(collection, keyName, maxDepth) {\n    return _locate_Key2(collection, keyName, maxDepth);\n  },\n  deepGet_Key: function deepGet_Key(collection, keyName, maxDepth) {\n    return _deepGet_Key(collection, keyName, maxDepth);\n  },\n  locateAll_Key: function locateAll_Key(collection, keyName, maxDepth) {\n    return _locateAll_Key2(collection, keyName, maxDepth);\n  },\n  deepFilter_Key: function deepFilter_Key(collection, keyName, maxDepth) {\n    return _deepFilter_Key(collection, keyName, maxDepth);\n  },\n  deepClone: function deepClone(identity, maxDepth, startDepth) {\n    return _deepClone2(identity, maxDepth, startDepth);\n  },\n  renameKey: function renameKey(identity, keyName, newKeyName, maxDepth) {\n    return _renameKey2(identity, keyName, newKeyName, maxDepth);\n  },\n  renameKeys: function renameKeys(identity, keyName, newKeyName, maxDepth) {\n    return _renameKeys2(identity, keyName, newKeyName, maxDepth);\n  },\n  deepRemove_Key: function deepRemove_Key(identity, keyName, maxDepth) {\n    return _deepRemove_Key(identity, keyName, maxDepth);\n  },\n  deepRemoveAll_Key: function deepRemoveAll_Key(identity, keyName, maxDepth) {\n    return _deepRemoveAll_Key(identity, keyName, maxDepth);\n  }\n};\nmodule.exports = exports = mitsuketa;","map":{"version":3,"names":["deepRemoveAll_Key","identity","keyName","maxDepth","getType","undefined","clonedIdentity","deepClone","paths","locateAll_Key","forEach","path","split","ref","Array","isArray","i","length","key","deepRemove_Key","locate_Key","renameKeys","newKeyName","_renameKeys","currentDepth","keys","Arr","Object","l","subIdentity","Obj","renameKey","applied","_renameKey","startDepth","R","_deepClone","isIterable","push","deepFilter_Key","collection","results","map","result","_locateAll_Key","xKey","subcollection","pop","join","deepGet_Key","_locate_Key","res","matchDepth","locate","maxLayer","_maxDepth","countMatches","nthDepth","depth","nthDepth_isNull","maxDepth_isNull","locateAll","count","onlyFalsy","identities","property","subCollection","deepFilter","isTruthy","foundFalsy","singleProperty","isFalsy","_foundFalsy","containsKeys","onlyTruthy","foundTruthy","_foundTruthy","propCount","indexOf","falser","onlyMissing","exists","onlyExisting","identical","sameType","trimmed","trim","splice","_locateAll","deepGet","_locate","keyList","identityType","keyCount","newIdentity","identitykeys","identityA","identityB","structureMatch","sameStructure","Keys","KeyCount","childMatch","Key","identicalMatch","typeMatch","AKeys","BKeys","AKeyCount","BKeyCount","typeA","it","mitsuketa","module","exports"],"sources":["D:/Projects/New/api-visualizer-tool/node_modules/react-json-editor-ajrm/es/mitsuketa/index.js"],"sourcesContent":["/**\r\n * @author Andrew Redican <andrew.redican.mejia@gmail.com>\r\n */\n\n/**\r\n * Performs deep search on object tree, removes all properties with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\nfunction deepRemoveAll_Key(identity, keyName, maxDepth) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  let clonedIdentity = deepClone(identity);\n  var paths = locateAll_Key(clonedIdentity, keyName, maxDepth);\n  if (paths === [] || paths === false) return clonedIdentity;\n  paths.forEach(path => {\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var ref = clonedIdentity;\n    if (!Array.isArray(path)) delete ref[path];\n\n    for (var i = 0; i < path.length; i++) {\n      var key = path[i];\n\n      if (key in ref) {\n        if (i < path.length - 1) ref = ref[key];else delete ref[key];\n      } else break;\n    }\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, removes the first property with matching key, returns a new identity without the specified property\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction deepRemove_Key(identity, keyName, maxDepth) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  let clonedIdentity = deepClone(identity);\n  var path = locate_Key(clonedIdentity, keyName, maxDepth);\n  if (path === false) return clonedIdentity;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var ref = clonedIdentity;\n  if (!Array.isArray(path)) delete ref[path];\n  path.forEach((key, i) => {\n    if (i < path.length - 1) ref = ref[key];else delete ref[key];\n  });\n  return clonedIdentity;\n}\n/**\r\n * Performs deep search on object tree, and renames the all matching keys\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction renameKeys(identity, keyName, newKeyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n\n  function _renameKeys(identity, keyName, newKeyName, maxDepth, currentDepth = 0) {\n    let keys;\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (key === keyName) key = newKeyName;\n          Obj[key] = _renameKeys(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKeys(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Performs deep search on object tree, then renames the first matching key\r\n * @param {Any} identity\r\n * @param {string} keyName\r\n * @param {string} newKeyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction renameKey(identity, keyName, newKeyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (getType(newKeyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  if (newKeyName === '') return undefined;\n  var applied = false;\n\n  function _renameKey(identity, keyName, newKeyName, maxDepth, currentDepth = 0) {\n    let keys;\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          Arr[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          let key = keys[i],\n              subIdentity = identity[key];\n          if (maxDepth !== null ? currentDepth < maxDepth : true) if (!applied) if (key === keyName) {\n            key = newKeyName;\n            applied = true;\n          }\n          Obj[key] = _renameKey(subIdentity, keyName, newKeyName, maxDepth, currentDepth + 1);\n        }\n\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  return _renameKey(identity, keyName, newKeyName, maxDepth, 0);\n}\n/**\r\n * Creates a non-reference clone that is an exact copy to the identity provided.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @param {Optional Number} startDepth\r\n * @return {Any} identity\r\n */\n\n\nfunction deepClone(identity, maxDepth = null, startDepth = null) {\n  var R = [];\n\n  function _deepClone(identity, maxDepth, startDepth, currentDepth = 0) {\n    let keys;\n\n    if (startDepth !== null ? currentDepth < startDepth : false) {\n      if (isIterable(identity)) {\n        keys = Object.keys(identity);\n        keys.forEach(key => {\n          _deepClone(identity[key], maxDepth, startDepth, currentDepth + 1);\n        });\n      }\n\n      return;\n    }\n\n    if (startDepth !== null ? currentDepth == startDepth : false) {\n      if (startDepth == 0) {\n        R = _deepClone(identity, maxDepth, null, currentDepth);\n        return;\n      }\n\n      if (isIterable(identity)) R.push(_deepClone(identity, maxDepth, startDepth, currentDepth + 1));\n      return;\n    }\n\n    switch (getType(identity)) {\n      case 'array':\n        var Arr = [];\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          const key = keys[i],\n                subIdentity = identity[key];\n          Arr[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Arr;\n\n      case 'object':\n        var Obj = {};\n        keys = Object.keys(identity);\n        if (maxDepth !== null ? currentDepth < maxDepth : true) for (var i = 0, l = keys.length; i < l; i++) {\n          const key = keys[i],\n                subIdentity = identity[key];\n          Obj[key] = _deepClone(subIdentity, maxDepth, startDepth, currentDepth + 1);\n        }\n        return Obj;\n\n      case 'string':\n        return '' + identity;\n\n      case 'number':\n        return 0 + identity;\n\n      case 'boolean':\n        if (identity) return true;\n        return false;\n\n      case 'null':\n        return null;\n\n      case 'undefined':\n        return undefined;\n    }\n  }\n\n  if (startDepth === null) return _deepClone(identity, maxDepth, startDepth, 0);\n\n  _deepClone(identity, maxDepth, startDepth, 0);\n\n  return R;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, and returns a list of identities containing the matched instances. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} Identities\r\n */\n\n\nfunction deepFilter_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var paths = locateAll_Key(collection, keyName, maxDepth);\n  if (paths === false) return undefined;\n  const results = paths.map(path => {\n    if (path === false) return undefined;\n    if (path === '') path = keyName;else path += '.' + keyName;\n    path = path.split('.');\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(key => {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the key name, returns the location of each match in a string array. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction locateAll_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var R = [];\n\n  function _locateAll_Key(collection, keyName, xKey = '', path = '', maxDepth = null, currentDepth = 0) {\n    if (xKey === keyName) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key];\n\n      _locateAll_Key(subcollection, keyName, key, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll_Key(collection, keyName, '', '', maxDepth);\n\n  R = R.map(path => {\n    if (getType(path) === 'boolean') return path;\n    if (path === '') return path;\n    path = path.split('.');\n    path.pop();\n    path = path.join('.');\n    return path;\n  });\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, and returns the first identity containing the match. If no match found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {Identity || undefined} identity\r\n */\n\n\nfunction deepGet_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n  var path = locate_Key(collection, keyName, maxDepth);\n  if (path === false) return undefined;\n  if (path === '') path = keyName;else path += '.' + keyName;\n  path = path.split('.');\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(key => {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the key name, will return the path of the first instance matched. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} keyName\r\n * @param {Optional number} maxDepth\r\n * @return {String || false} Path\r\n */\n\n\nfunction locate_Key(collection, keyName, maxDepth = null) {\n  if (getType(keyName) !== 'string') return undefined;\n  if (keyName === '') return undefined;\n\n  function _locate_Key(collection, keyName, path = '', maxDepth, currentDepth = 0) {\n    if (path === keyName) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _locate_Key(subcollection, keyName, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  var path = _locate_Key(collection, keyName, '', maxDepth, 0);\n\n  if (getType(path) === 'boolean') return path;\n  if (path === '') return path;\n  path = path.split('.');\n  path.pop();\n  path = path.join('.');\n  return path;\n}\n/**\r\n * Performs deep search for identity on collection to return the location's depth of the first match. If no match found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean}\r\n */\n\n\nfunction matchDepth(collection, identity, maxDepth = null) {\n  var path = locate(collection, identity, maxDepth);\n  if (path === false) return false;\n  if (path === '') return 0;\n  path = path.split('.');\n  return path.length;\n}\n/**\r\n * Walks through the entire object tree to return the maximum number of layers it contains.\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n */\n\n\nfunction maxDepth(identity, maxLayer = null) {\n  let R = 0;\n\n  function _maxDepth(identity, maxLayer, currentDepth = 0) {\n    if (R < currentDepth) R = currentDepth;\n    if (maxLayer !== null) if (currentDepth >= maxLayer) return;\n\n    if (isIterable(identity)) {\n      var keys = Object.keys(identity);\n      keys.forEach(key => {\n        var subIdentity = identity[key];\n\n        _maxDepth(subIdentity, maxLayer, currentDepth + 1);\n      });\n    }\n  }\n\n  _maxDepth(identity, maxLayer);\n\n  return R;\n}\n/**\r\n * Performs deep search for identity on collection, returns the number of matches found.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Number} nthDepth\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns number of matches found.\r\n */\n\n\nfunction countMatches(collection, identity, nthDepth = null, maxDepth = null) {\n  var depth,\n      nthDepth_isNull = nthDepth === null,\n      maxDepth_isNull = maxDepth === null;\n  if (nthDepth_isNull && maxDepth_isNull) depth = null;else if (!nthDepth_isNull && !maxDepth_isNull) {\n    if (nthDepth < maxDepth) depth = nthDepth;else depth = maxDepth;\n  } else if (nthDepth) depth = nthDepth;else depth = maxDepth;\n  var paths = locateAll(collection, identity, depth);\n  if (paths === false) return 0;\n  if (nthDepth === null) return paths.length;\n\n  if (getType(nthDepth) === 'number') {\n    let count = 0;\n    paths.forEach(path => {\n      path = path.split('.');\n      if (path.length === nthDepth) count++;\n    });\n    return count;\n  }\n\n  return undefined;\n}\n/**\r\n* Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n* @param {Any} collection\r\n* @param {Any} identities\r\n* @param {Any} property\r\n* @param {Optional Number} maxDepth\r\n* @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n*/\n\n\nfunction onlyFalsy(collection, identities, property, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      const subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundFalsy(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      const identity = identities[key],\n            subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundFalsy(subCollection, property, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (foundFalsy(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction foundFalsy(collection, identity, maxDepth = null) {\n  identity = singleProperty(identity);\n  if (isFalsy(identity)) return undefined;\n\n  function _foundFalsy(collection, identity, maxDepth, currentDepth = 0) {\n    if (containsKeys(collection, [identity])) return isFalsy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _foundFalsy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundFalsy(collection, identity, maxDepth);\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Any} property\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction onlyTruthy(collection, identities, property, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      const subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundTruthy(subCollection, property, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      const identity = identities[key],\n            subCollection = deepFilter(collection, identity);\n      if (isTruthy(subCollection)) if (foundTruthy(subCollection, property, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (foundTruthy(collection, property, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the property and evalutates if truthy\r\n * @param {Any} collection\r\n * @param {Property} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If match confirmed and truthy will return true, otherwise false\r\n */\n\n\nfunction foundTruthy(collection, identity, maxDepth = null) {\n  identity = singleProperty(identity);\n  if (isFalsy(identity)) return undefined;\n\n  function _foundTruthy(collection, identity, maxDepth, currentDepth = 0) {\n    if (containsKeys(collection, [identity])) return isTruthy(collection[identity]);\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return false;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _foundTruthy(subcollection, identity, maxDepth, currentDepth + 1);\n\n      if (res) return true;\n    }\n    return false;\n  }\n\n  return _foundTruthy(collection, identity, maxDepth, 0);\n}\n/**\r\n * Validates if identity is equal to a property definition or contains a single property key.\r\n * @param {Property} identity\r\n * @return {String || boolean} If criteria matched will return property name as string, otherwise false\r\n */\n\n\nfunction singleProperty(identity) {\n  const propCount = length(identity);\n  if (propCount > 1) return false;\n  if (propCount === 1) return Object.keys(identity)[0];\n  if (propCount === 0) if (['string', 'number'].indexOf(getType(identity)) > -1) return identity;\n  return false;\n}\n/**\r\n * Determines if identity is non-falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction isTruthy(identity) {\n  return !isFalsy(identity);\n}\n/**\r\n * Determines if identity is falsy\r\n * @param {Any} identity\r\n * @return {boolean} Returns true if criteria matched, otherwise false.\r\n */\n\n\nfunction isFalsy(identity) {\n  if (falser(identity) === false) return true;\n  return false;\n}\n/**\r\n * Converts false-like values into actual boolean value of false\r\n * @param {Any} identity\r\n * @return {Any || boolean} Returns false is value is falsy, otherwise returns original value.\r\n */\n\n\nfunction falser(identity) {\n  if (isIterable(identity)) return identity;\n  if (['null', 'undefined'].indexOf(getType(identity)) > -1) return false;\n  if (['', 0, false].indexOf(identity) > -1) return false;\n  return identity;\n}\n/**\r\n * Check the length of the top-most depth of the identity\r\n * @param {Any} identity\r\n * @return {integer} Greater than or equal to 0.\r\n */\n\n\nfunction length(identity) {\n  if (['array', 'object'].indexOf(getType(identity)) === -1) return 0;\n  return Object.keys(identity).length;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that does meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that were not matched.\r\n */\n\n\nfunction onlyMissing(collection, identities, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      if (!exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      let identity = identities[key];\n      if (!exists(collection, identity, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (!exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search for each identity on collection, to shorten the identities to those that meets the match criteria\r\n * @param {Any} collection\r\n * @param {Any} identities\r\n * @param {Optional Number} maxDepth\r\n * @return {Any} Returns a collection of the same type as the 'identities' parameter provided with only the identities that matched.\r\n */\n\n\nfunction onlyExisting(collection, identities, maxDepth = null) {\n  if (getType(identities) === 'array') {\n    let result = [];\n    identities.forEach(identity => {\n      if (exists(collection, identity, maxDepth)) result.push(identity);\n    });\n    return result;\n  }\n\n  if (getType(identities) === 'object') {\n    let result = {};\n    Object.keys(identities).forEach(key => {\n      let identity = identities[key];\n      if (exists(collection, identity, maxDepth)) result[key] = identity;\n    });\n    return result;\n  }\n\n  if (exists(collection, identities, maxDepth)) return identities;\n}\n/**\r\n * Performs deep search on collection to find any match to the identity\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {boolean} If a match is confirmed will return true, otherwise false\r\n */\n\n\nfunction exists(collection, identity, maxDepth = null, currentDepth = 0) {\n  if (identical(collection, identity)) return true;\n  if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n    const trimmed = trim(collection, Object.keys(identity));\n    if (identical(trimmed, identity)) return true;\n  }\n  if (maxDepth === null ? true : currentDepth < maxDepth) if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n    const key = keys[i],\n          subcollection = collection[key],\n          res = exists(subcollection, identity, maxDepth, currentDepth + 1);\n    if (res) return true;\n  }\n  return false;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, will return a list of identities containing the match. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || undefined} identities\r\n */\n\n\nfunction deepFilter(collection, identity, maxDepth = null) {\n  var paths = locateAll(collection, identity, maxDepth);\n  if (paths === false) return undefined;\n  const results = paths.map(path => {\n    if (path === '') return collection;\n    path = path.split('.');\n    if (['array', 'object'].indexOf(getType(identity)) === -1) path.splice(-1, 1);\n    var result = collection;\n    if (!Array.isArray(path)) return result[path];\n    path.forEach(key => {\n      result = result[key];\n    });\n    return result;\n  });\n  return results;\n}\n/**\r\n * Performs deep search on collection to find all matches to the identity, returns a string array containing the location of all matches. If no matches found, it returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {Array || false} Paths\r\n */\n\n\nfunction locateAll(collection, identity, maxDepth = null) {\n  var R = [];\n\n  function _locateAll(collection, identity, path = '', maxDepth, currentDepth) {\n    if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n      const trimmed = trim(collection, Object.keys(identity));\n      if (identical(trimmed, identity)) R[R.length] = path;\n    }\n    if (identical(collection, identity)) R[R.length] = path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key];\n\n      _locateAll(subcollection, identity, (path === '' ? path : path + '.') + key, maxDepth, currentDepth + 1);\n    }\n  }\n\n  _locateAll(collection, identity, '', maxDepth, 0);\n\n  return R.length === 0 ? false : R;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the identity containing of the first instance matched. If no matches found, it returns `undefined`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional Number} maxDepth\r\n * @return {identity || undefined} identity\r\n */\n\n\nfunction deepGet(collection, identity, maxDepth = null) {\n  var path = locate(collection, identity, maxDepth);\n  if (path === false) return undefined;\n  if (path === '') return collection;\n  path = path.split('.');\n  if (['array', 'object'].indexOf(getType(identity)) === -1) path.splice(-1, 1);\n  var result = collection;\n  if (!Array.isArray(path)) return result[path];\n  path.forEach(key => {\n    result = result[key];\n  });\n  return result;\n}\n/**\r\n * Performs deep search on collection to find a match to the identity, will return the path of the first instance matched as string. If no matches found, returns `false`.\r\n * @param {Any} collection\r\n * @param {Any} identity\r\n * @param {Optional number} maxDepth\r\n * @return {string || false} path\r\n */\n\n\nfunction locate(collection, identity, maxDepth = null) {\n  function _locate(collection, identity, path = '', maxDepth, currentDepth) {\n    if (isIterable(identity)) if (sameType(collection, identity)) if (containsKeys(collection, Object.keys(identity))) {\n      const trimmed = trim(collection, Object.keys(identity));\n      if (identical(trimmed, identity)) return path;\n    }\n    if (identical(collection, identity)) return path;\n    var result = false;\n    if (maxDepth !== null) if (currentDepth >= maxDepth) return result;\n    if (isIterable(collection)) for (var i = 0, keys = Object.keys(collection), l = keys.length; i < l; i++) {\n      const key = keys[i],\n            subcollection = collection[key],\n            res = _locate(subcollection, identity, key, maxDepth, currentDepth + 1);\n\n      if (res) {\n        path = path === '' ? path : path + '.';\n        result = path + res;\n        break;\n      }\n    }\n    return result;\n  }\n\n  return _locate(collection, identity, '', maxDepth, 0);\n}\n/**\r\n * Trims an identity to only contain the specified properties.\r\n * @param {Any} identity\r\n * @param {Any} keyList\r\n * @return {Object or Array} Returns , otherwise false\r\n */\n\n\nfunction trim(identity, keyList) {\n  const identityType = getType(identity);\n  if (['array', 'object'].indexOf(identityType) === -1) return undefined;\n  const keyCount = keyList.length;\n  if (keyCount === 0) return undefined;\n  var newIdentity;\n\n  switch (identityType) {\n    case 'object':\n      newIdentity = {};\n      keyList.forEach(key => {\n        if (key in identity) newIdentity[key] = identity[key];\n      });\n      break;\n\n    case 'array':\n      newIdentity = [];\n      keyList.forEach(key => {\n        if (key in identity) newIdentity.push(identity[key]);\n      });\n      break;\n  }\n\n  return newIdentity;\n}\n/**\r\n * Check if identity contains all of the specified keys\r\n * @param {Any} identity\r\n * @param {Array} keyList\r\n * @return {boolean} true || false\r\n */\n\n\nfunction containsKeys(identity, keyList) {\n  const keyCount = keyList.length;\n  if (keyCount === 0 || !isIterable(identity)) return false;\n  const identitykeys = Object.keys(identity);\n  var result = true;\n\n  for (var i = 0; i < keyCount; i++) {\n    const key = '' + keyList[i];\n\n    if (identitykeys.indexOf(key) === -1) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n}\n/**\r\n * Check if identity has one or more keys to iterate\r\n * @param {Any} identity\r\n * @return {boolean} true || false\r\n */\n\n\nfunction isIterable(identity) {\n  if (['array', 'object'].indexOf(getType(identity)) === -1) return false;\n  if (Object.keys(identity).length === 0) return false;\n  return true;\n}\n/**\r\n * Compares two identities, will return either true if identical, otherwise false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction identical(identityA, identityB) {\n  const structureMatch = sameStructure(identityA, identityB);\n  if (structureMatch === false) return structureMatch;\n  if (['array', 'object'].indexOf(structureMatch) === -1) return identityA === identityB;\n  const Keys = Object.keys(identityA),\n        KeyCount = Keys.length;\n  var childMatch = true;\n\n  for (var i = 0; i < KeyCount; i++) {\n    const Key = Keys[i],\n          identicalMatch = identical(identityA[Key], identityB[Key]);\n\n    if (identicalMatch === false) {\n      childMatch = identicalMatch;\n      break;\n    }\n\n    ;\n  }\n\n  return childMatch;\n}\n/**\r\n * Compares data structure of two identities, will return either the dataType or true/false.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {String || False} DataType as string for positive match, otherwise false\r\n */\n\n\nfunction sameStructure(identityA, identityB) {\n  const typeMatch = sameType(identityA, identityB);\n  if (typeMatch === false) return false;\n\n  if (['array', 'object'].indexOf(typeMatch) > -1) {\n    const AKeys = Object.keys(identityA),\n          BKeys = Object.keys(identityB),\n          AKeyCount = AKeys.length,\n          BKeyCount = BKeys.length;\n    if (!(AKeyCount === BKeyCount)) return false;\n    if (AKeyCount === 0) return true;\n\n    for (var i = 0; i < AKeyCount; i++) {\n      if (AKeys[i] !== BKeys[i]) return false;\n    }\n  }\n\n  return typeMatch;\n}\n/**\r\n * Compares data type of two identities, will dataType if true.\r\n * @param {Any} identityA\r\n * @param {Any} identityB\r\n * @return {boolean} true || false\r\n */\n\n\nfunction sameType(identityA, identityB) {\n  const typeA = getType(identityA);\n  return typeA === getType(identityB) ? typeA : false;\n}\n/**\r\n * Gets data type; makes distintion between object, array, and null.\r\n * @param {Any} identity\r\n * @return {String} dataType\r\n */\n\n\nfunction getType(identity) {\n  if (identity === null) return 'null';\n  const it = typeof identity;\n  if (it === 'object') if (Array.isArray(identity)) return 'array';\n  return it;\n}\n\nvar mitsuketa = {\n  getType: function (identity) {\n    return getType(identity);\n  },\n  sameType: function (identityA, identityB) {\n    return sameType(identityA, identityB);\n  },\n  sameStructure: function (identityA, identityB) {\n    return sameStructure(identityA, identityB);\n  },\n  identical: function (identityA, identityB) {\n    return identical(identityA, identityB);\n  },\n  isIterable: function (identity) {\n    return isIterable(identity);\n  },\n  containsKeys: function (identity, keyList) {\n    return containsKeys(identity, keyList);\n  },\n  trim: function (identity, keyList) {\n    return trim(identity, keyList);\n  },\n  locate: function (collection, identity, maxDepth) {\n    return locate(collection, identity, maxDepth);\n  },\n  deepGet: function (collection, identity, maxDepth) {\n    return deepGet(collection, identity, maxDepth);\n  },\n  locateAll: function (collection, identity, maxDepth) {\n    return locateAll(collection, identity, maxDepth);\n  },\n  deepFilter: function (collection, identity, maxDepth) {\n    return deepFilter(collection, identity, maxDepth);\n  },\n  exists: function (collection, identity, maxDepth) {\n    return exists(collection, identity, maxDepth);\n  },\n  onlyExisting: function (collection, identities, maxDepth) {\n    return onlyExisting(collection, identities, maxDepth);\n  },\n  onlyMissing: function (collection, identities, maxDepth) {\n    return onlyMissing(collection, identities, maxDepth);\n  },\n  length: function (identity) {\n    return length(identity);\n  },\n  isFalsy: function (identity) {\n    return isFalsy(identity);\n  },\n  isTruthy: function (identity) {\n    return isTruthy(identity);\n  },\n  foundTruthy: function (collection, identity, maxDepth) {\n    return foundTruthy(collection, identity, maxDepth);\n  },\n  onlyTruthy: function (collection, identities, property, maxDepth) {\n    return onlyTruthy(collection, identities, property, maxDepth);\n  },\n  foundFalsy: function (collection, identity, maxDepth) {\n    return foundFalsy(collection, identity, maxDepth);\n  },\n  onlyFalsy: function (collection, identities, property, maxDepth) {\n    return onlyFalsy(collection, identities, property, maxDepth);\n  },\n  countMatches: function (collection, identity, nthDepth, maxDepth) {\n    return countMatches(collection, identity, nthDepth, maxDepth);\n  },\n  matchDepth: function (collection, identity, maxDepth) {\n    return matchDepth(collection, identity, maxDepth);\n  },\n  maxDepth: function (identity, maxLayer) {\n    return maxDepth(identity, maxLayer);\n  },\n  locate_Key: function (collection, keyName, maxDepth) {\n    return locate_Key(collection, keyName, maxDepth);\n  },\n  deepGet_Key: function (collection, keyName, maxDepth) {\n    return deepGet_Key(collection, keyName, maxDepth);\n  },\n  locateAll_Key: function (collection, keyName, maxDepth) {\n    return locateAll_Key(collection, keyName, maxDepth);\n  },\n  deepFilter_Key: function (collection, keyName, maxDepth) {\n    return deepFilter_Key(collection, keyName, maxDepth);\n  },\n  deepClone: function (identity, maxDepth, startDepth) {\n    return deepClone(identity, maxDepth, startDepth);\n  },\n  renameKey: function (identity, keyName, newKeyName, maxDepth) {\n    return renameKey(identity, keyName, newKeyName, maxDepth);\n  },\n  renameKeys: function (identity, keyName, newKeyName, maxDepth) {\n    return renameKeys(identity, keyName, newKeyName, maxDepth);\n  },\n  deepRemove_Key: function (identity, keyName, maxDepth) {\n    return deepRemove_Key(identity, keyName, maxDepth);\n  },\n  deepRemoveAll_Key: function (identity, keyName, maxDepth) {\n    return deepRemoveAll_Key(identity, keyName, maxDepth);\n  }\n};\nmodule.exports = exports = mitsuketa;"],"mappings":"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"},"metadata":{},"sourceType":"script"}