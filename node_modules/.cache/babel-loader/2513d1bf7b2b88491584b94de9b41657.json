{"ast":null,"code":"import { getType, locate } from './mitsuketa';\nvar err = {\n  getCaller: function getCaller() {\n    var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    // A somewhat hacky solution that will yield different results in different JS engines. \n    // Since we only call this function when an error will actually be thrown we typically don't \n    // rally mind the performance impact this might have if called too often.\n    // Lucky for us we use nodeJS and thus only V8.\n    var stackTrace = new Error().stack;\n    var callerName = stackTrace.replace(/^Error\\s+/, '');\n    callerName = callerName.split(\"\\n\")[skip];\n    callerName = callerName.replace(/^\\s+at Object./, '').replace(/^\\s+at /, '').replace(/ \\(.+\\)$/, '');\n    return callerName;\n  },\n  throwError: function throwError() {\n    var fxName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown function';\n    var paramName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown parameter';\n    var expectation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'to be defined';\n    throw ['@', fxName, '(): Expected parameter \\'', paramName, '\\' ', expectation].join('');\n  },\n  isUndefined: function isUndefined() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    if ([null, undefined].indexOf(param) > -1) err.throwError(err.getCaller(2), paramName);\n  },\n  isFalsy: function isFalsy() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    if (!param) err.throwError(err.getCaller(2), paramName);\n  },\n  isNoneOf: function isNoneOf() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var contains = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (contains.indexOf(param) === -1) err.throwError(err.getCaller(2), paramName, 'to be any of' + JSON.stringify(contains));\n  },\n  isAnyOf: function isAnyOf() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var contains = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    if (contains.indexOf(param) > -1) err.throwError(err.getCaller(2), paramName, 'not to be any of' + JSON.stringify(contains));\n  },\n  isNotType: function isNotType() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    if (getType(param) !== type.toLowerCase()) err.throwError(err.getCaller(2), paramName, 'to be type ' + type.toLowerCase());\n  },\n  isAnyTypeOf: function isAnyTypeOf() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var types = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    types.forEach(function (type) {\n      if (getType(param) === type) err.throwError(err.getCaller(2), paramName, 'not to be type of ' + type.toLowerCase());\n    });\n  },\n  missingKey: function missingKey() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var keyName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    err.isUndefined(paramName, param);\n    if (Object.keys(param).indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n  },\n  missingAnyKeys: function missingAnyKeys() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    var keyNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [''];\n    err.isUndefined(paramName, param);\n    var keyList = Object.keys(param);\n    keyNames.forEach(function (keyName) {\n      if (keyList.indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n    });\n  },\n  containsUndefined: function containsUndefined() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    [undefined, null].forEach(function (value) {\n      var location = locate(param, value);\n      if (location) err.throwError(err.getCaller(2), paramName, 'not to contain \\'' + JSON.stringify(value) + '\\' at ' + location);\n    });\n  },\n  isInvalidPath: function isInvalidPath() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    err.isUndefined(paramName, param);\n    err.isNotType(paramName, param, 'string');\n    err.isAnyOf(paramName, param, ['', '/']);\n    '.$[]#'.split().forEach(function (invalidChar) {\n      if (param.indexOf(invalidChar) > -1) err.throwError(err.getCaller(2), paramName, 'not to contain invalid character \\'' + invalidChar + '\\'');\n    });\n    if (param.match(/\\/{2,}/g)) err.throwError(err.getCaller(2), paramName, 'not to contain consecutive forward slash characters');\n  },\n  isInvalidWriteData: function isInvalidWriteData() {\n    var paramName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '<unknown parameter>';\n    var param = arguments.length > 1 ? arguments[1] : undefined;\n    err.isUndefined(paramName, param);\n    err.containsUndefined(paramName, param);\n  }\n};\nexport default err;","map":{"version":3,"names":["getType","locate","err","getCaller","skip","stackTrace","Error","stack","callerName","replace","split","throwError","fxName","paramName","expectation","join","isUndefined","param","undefined","indexOf","isFalsy","isNoneOf","contains","JSON","stringify","isAnyOf","isNotType","type","toLowerCase","isAnyTypeOf","types","forEach","missingKey","keyName","Object","keys","missingAnyKeys","keyNames","keyList","containsUndefined","value","location","isInvalidPath","invalidChar","match","isInvalidWriteData"],"sources":["D:/Projects/New/api-visualizer-tool/node_modules/react-json-editor-ajrm/es/err.js"],"sourcesContent":["import { getType, locate } from './mitsuketa';\nconst err = {\n  getCaller: (skip = 1) => {\n    // A somewhat hacky solution that will yield different results in different JS engines. \n    // Since we only call this function when an error will actually be thrown we typically don't \n    // rally mind the performance impact this might have if called too often.\n    // Lucky for us we use nodeJS and thus only V8.\n    const stackTrace = new Error().stack;\n    var callerName = stackTrace.replace(/^Error\\s+/, '');\n    callerName = callerName.split(\"\\n\")[skip];\n    callerName = callerName.replace(/^\\s+at Object./, '').replace(/^\\s+at /, '').replace(/ \\(.+\\)$/, '');\n    return callerName;\n  },\n  throwError: (fxName = 'unknown function', paramName = 'unknown parameter', expectation = 'to be defined') => {\n    throw ['@', fxName, '(): Expected parameter \\'', paramName, '\\' ', expectation].join('');\n  },\n  isUndefined: (paramName = '<unknown parameter>', param) => {\n    if ([null, undefined].indexOf(param) > -1) err.throwError(err.getCaller(2), paramName);\n  },\n  isFalsy: (paramName = '<unknown parameter>', param) => {\n    if (!param) err.throwError(err.getCaller(2), paramName);\n  },\n  isNoneOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) === -1) err.throwError(err.getCaller(2), paramName, 'to be any of' + JSON.stringify(contains));\n  },\n  isAnyOf: (paramName = '<unknown parameter>', param, contains = []) => {\n    if (contains.indexOf(param) > -1) err.throwError(err.getCaller(2), paramName, 'not to be any of' + JSON.stringify(contains));\n  },\n  isNotType: (paramName = '<unknown parameter>', param, type = '') => {\n    if (getType(param) !== type.toLowerCase()) err.throwError(err.getCaller(2), paramName, 'to be type ' + type.toLowerCase());\n  },\n  isAnyTypeOf: (paramName = '<unknown parameter>', param, types = []) => {\n    types.forEach(type => {\n      if (getType(param) === type) err.throwError(err.getCaller(2), paramName, 'not to be type of ' + type.toLowerCase());\n    });\n  },\n  missingKey: (paramName = '<unknown parameter>', param, keyName = '') => {\n    err.isUndefined(paramName, param);\n    if (Object.keys(param).indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n  },\n  missingAnyKeys: (paramName = '<unknown parameter>', param, keyNames = ['']) => {\n    err.isUndefined(paramName, param);\n    const keyList = Object.keys(param);\n    keyNames.forEach(keyName => {\n      if (keyList.indexOf(keyName) === -1) err.throwError(err.getCaller(2), paramName, 'to contain \\'' + keyName + '\\' key');\n    });\n  },\n  containsUndefined: (paramName = '<unknown parameter>', param) => {\n    [undefined, null].forEach(value => {\n      const location = locate(param, value);\n      if (location) err.throwError(err.getCaller(2), paramName, 'not to contain \\'' + JSON.stringify(value) + '\\' at ' + location);\n    });\n  },\n  isInvalidPath: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.isNotType(paramName, param, 'string');\n    err.isAnyOf(paramName, param, ['', '/']);\n    '.$[]#'.split().forEach(invalidChar => {\n      if (param.indexOf(invalidChar) > -1) err.throwError(err.getCaller(2), paramName, 'not to contain invalid character \\'' + invalidChar + '\\'');\n    });\n    if (param.match(/\\/{2,}/g)) err.throwError(err.getCaller(2), paramName, 'not to contain consecutive forward slash characters');\n  },\n  isInvalidWriteData: (paramName = '<unknown parameter>', param) => {\n    err.isUndefined(paramName, param);\n    err.containsUndefined(paramName, param);\n  }\n};\nexport default err;"],"mappings":"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"},"metadata":{},"sourceType":"module"}